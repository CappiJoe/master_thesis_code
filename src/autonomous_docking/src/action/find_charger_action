#! /usr/bin/env python

########################## SEND GOAL POSE#####################

import rospy, actionlib, tf
from geometry_msgs.msg import Twist, Pose, PoseStamped
from sensor_msgs.msg import LaserScan
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
import numpy as np
import math
import angles

class detect_charger(object):
    def __init__(self):
        rospy.Subscriber("scan", LaserScan, self.laser_scan, queue_size=None)
        self.move_to_charger = actionlib.SimpleActionClient('move_to_charger_action', MoveBaseAction)
        self.move_to_charger.wait_for_server()


    def publish_goal(self,goal_coordinates):
        #Define goal message parameters
        goal = MoveBaseGoal()
        goal.target_pose.header.stamp = rospy.Time.now()
        goal.target_pose.header.frame_id = "odom"

        #Charger pose
        x = goal_coordinates[0]
        y = goal_coordinates[1]
        psi_g = goal_coordinates[2]

        #Define goal pose
        goal.target_pose.pose.position.x = x
        goal.target_pose.pose.position.y = y

        quatern = tf.transformations.quaternion_from_euler(0,0,psi_g)
        goal.target_pose.pose.orientation.x = quatern[0]
        goal.target_pose.pose.orientation.y = quatern[1]
        goal.target_pose.pose.orientation.z = quatern[2]
        goal.target_pose.pose.orientation.w = quatern[3]
        self.move_to_charger.send_goal(goal)
        wait = self.move_to_charger.wait_for_result()
        if not wait:
            rospy.logerr("Server unavailable")
            rospy.signal_shutdown("Server Unavailable")
        else:
            print("Hey bitch")

    def laser_scan(self, scan_msg):
        rate = rospy.Rate(0.2)
        #Data of interest from the scan:
        scan_ranges = scan_msg.ranges
        scan_angle_min = scan_msg.angle_min
        scan_angle_inc = scan_msg.angle_increment
        scan_intensities = np.zeros_like(scan_ranges) #scan_msg.intensities
        intensity_threshold = 15000 ###Change after testing
        #Thorvald's current position
        #base_link_pos = np.array([Thorvald_state.x0, Thorvald_state.y0])
        #Empty array for the points of interest

        ################################### FOR TEST ########################
        test_idx = [idx for idx,val in enumerate(scan_ranges) if val<51 and val>0]
        for k in test_idx:
            scan_intensities[k] = 16000
        ####################################################################

        #Find the points with increased intensity
        cluster_points_distances = np.array([])
        cluster_points_angles = np.array([])
        for idx, distance in enumerate(scan_ranges):
            point_intensity = scan_intensities[idx]
            if point_intensity > intensity_threshold:
                point_angle = scan_angle_min + idx*scan_angle_inc #Start angle + n.o. angle increment to current laser tag
                cluster_points_distances = np.append(cluster_points_distances, distance)
                cluster_points_angles = np.append(cluster_points_angles, point_angle)
        cluster_points = np.array([cluster_points_distances,cluster_points_angles])

        #Sort the into two clusters based on distance><mean
        close_cluster_distance = np.array([])
        close_cluster_angle = np.array([])
        far_cluster_distance = np.array([])
        far_cluster_angle = np.array([])
        for idx, val in enumerate(cluster_points[0]):
            if val < np.mean(cluster_points[0]):
                close_cluster_distance = np.append(close_cluster_distance,cluster_points[0][idx])
                close_cluster_angle = np.append(close_cluster_angle,cluster_points[1][idx])
            else:
                far_cluster_distance = np.append(far_cluster_distance,cluster_points[0][idx])
                far_cluster_angle = np.append(far_cluster_angle,cluster_points[1][idx])

        #Take the mean of the closest and furthest cluster to approximate the position of the pillar.
        closest_point = np.array([np.mean(close_cluster_distance),np.mean(close_cluster_angle)])
        furthest_point = np.array([np.mean(far_cluster_distance),np.mean(far_cluster_angle)])
        #
        closest_pillar_coor = np.array([closest_point[0]*math.cos(closest_point[1]),closest_point[0]*math.sin(closest_point[1])])
        furthest_pillar_coor = np.array([furthest_point[0]*math.cos(furthest_point[1]),furthest_point[0]*math.sin(furthest_point[1])])


        #Define the coordinates of the final docking point
        docking_coor = ((closest_pillar_coor+furthest_pillar_coor)-1)/2
        print(docking_coor)
        alpha = abs(closest_point[1]-furthest_point[1])
        a_2 = furthest_point[1]-closest_point[1]*math.cos(alpha)
        x = closest_point[1]*math.sin(alpha)
        psi_g = angles.normalize_angle((math.pi/2)-math.atan2(x,a_2))
        goal_coordinates = [docking_coor[0],docking_coor[1],psi_g]
        self.publish_goal(goal_coordinates)
        print(goal_coordinates)
        rate.sleep()

if __name__ == "__main__":
    rospy.init_node("charger_detector", anonymous=False)
    #Connect with server
    detect_charger()
