#! /usr/bin/env python

import rospy, tf
from geometry_msgs.msg import Twist, Pose, PoseArray, PoseStamped
from sensor_msgs.msg import LaserScan
import numpy as np
import math
import angles

class detect_charger_laser(object):
    def __init__(self):
        rospy.Subscriber("/scan", LaserScan, self.laser_scan, queue_size=1)
        self.charger_publisher = rospy.Publisher('/laser_waypoints', PoseArray, queue_size=1) # Publishing msg to the nav_vel topic. Twist as msg type.
        self.lt = tf.TransformListener()

    def laser_scan(self, scan_msg):
        """ Get the data from the laser scan """
        rate = rospy.Rate(10)
        scan_ranges = scan_msg.ranges
        scan_angle_min = scan_msg.angle_min
        scan_angle_inc = scan_msg.angle_increment
        scan_intensities = np.zeros_like(scan_ranges) #scan_msg.intensities
        intensity_threshold = 15000 ###Change after testing

        ################################### FOR TEST ########################
        test_idx = [idx for idx,val in enumerate(scan_ranges) if val<51 and val>0]
        for k in test_idx:
            scan_intensities[k] = 16000
        ####################################################################


        """ Filter out point under the desired threshold """
        intense_points_distances = np.array([])
        intense_points_angles = np.array([])
        for idx, distance in enumerate(scan_ranges):
            point_intensity = scan_intensities[idx]
            if point_intensity > intensity_threshold:
                point_angle = scan_angle_min + idx*scan_angle_inc #Start angle + n.o. angle increment to current laser tag
                intense_points_distances = np.append(intense_points_distances, distance)
                intense_points_angles = np.append(intense_points_angles, point_angle)
        intense_points = np.array([intense_points_distances,intense_points_angles])


        """ Based on the mean distance, sort the group of points into two clusters"""
        close_cluster_distance = np.array([])
        close_cluster_angle = np.array([])
        far_cluster_distance = np.array([])
        far_cluster_angle = np.array([])
        for idx, val in enumerate(intense_points[0]):
            if val < np.mean(intense_points[0]):
                close_cluster_distance = np.append(close_cluster_distance,intense_points[0][idx])
                close_cluster_angle = np.append(close_cluster_angle,intense_points[1][idx])
            else:
                far_cluster_distance = np.append(far_cluster_distance,intense_points[0][idx])
                far_cluster_angle = np.append(far_cluster_angle,intense_points[1][idx])

        """ Define the two detected points as the mean of each cluster """
        closest_point = np.array([np.mean(close_cluster_distance),np.mean(close_cluster_angle)])
        furthest_point = np.array([np.mean(far_cluster_distance),np.mean(far_cluster_angle)])

        # Coordinates of the pillars
        closest_pillar_coor = np.array([closest_point[0]*math.cos(closest_point[1]),closest_point[0]*math.sin(closest_point[1])])
        furthest_pillar_coor = np.array([furthest_point[0]*math.cos(furthest_point[1]),furthest_point[0]*math.sin(furthest_point[1])])

        """ Define the waypoints """
        charger_pose, ref_point = self.calculate_waypoints(closest_point,furthest_point)
        waypoint_pose = PoseStamped()
        waypoint_pose.pose.position.x = ref_point[0]
        waypoint_pose.pose.position.y = ref_point[1]
        waypoint_pose.pose.position.z = 0.0
        ref_pose_quat = tf.transformations.quaternion_from_euler(0,0,ref_point[2])
        waypoint_pose.pose.orientation.x = ref_pose_quat[0]
        waypoint_pose.pose.orientation.y = ref_pose_quat[1]
        waypoint_pose.pose.orientation.z = ref_pose_quat[2]
        waypoint_pose.pose.orientation.w = ref_pose_quat[3]
        waypoint_pose.header.stamp = rospy.Time(0)
        waypoint_pose.header.seq = 1
        waypoint_pose.header.frame_id = "base_link"

        transf = self.lt.lookupTransform("base_link", "odom", rospy.Time(0))
        transformed_waypoint_pose = self.lt.transformPose("odom", waypoint_pose)
        transformed_waypoint_pose.pose.position.z = 0.0

        goal_pose = PoseStamped()
        goal_pose.pose.position.x = charger_pose[0]
        goal_pose.pose.position.y = charger_pose[1]
        goal_pose.pose.position.z = 0.0
        goal_pose_quat = tf.transformations.quaternion_from_euler(0,0,ref_point[2])
        goal_pose.pose.orientation.x = goal_pose_quat[0]
        goal_pose.pose.orientation.y = goal_pose_quat[1]
        goal_pose.pose.orientation.z = goal_pose_quat[2]
        goal_pose.pose.orientation.w = goal_pose_quat[3]
        goal_pose.header.stamp = rospy.Time(0)
        goal_pose.header.seq = 2
        goal_pose.header.frame_id = "base_link"
        transformed_goal_pose = self.lt.transformPose("odom", goal_pose)
        transformed_goal_pose.pose.position.z = 0.0


        pose_array = PoseArray()
        pose_array.poses = [transformed_goal_pose.pose,transformed_waypoint_pose.pose]
        self.charger_publisher.publish(pose_array)
        print("The waypoint pose is: %s" % str(transformed_waypoint_pose))
        print("The goal pose is: %s" % str(transformed_goal_pose))

    def calculate_waypoints(self,p_a,p_b):
        '''
        Caluclating a point a given distance (3m) in front of the charging station
        as an inital pose before the fine operation of the docking takes place.
        '''
        pose_time = rospy.Rate(10)

        """ Define p1 as the point with the smallest absolute angle. """
        if abs(p_a[1]) < abs(p_b[1]):
            p1 = p_a
            p2 = p_b
        else:
            p1 = p_b
            p2 = p_a

        angle_between_p1_p2 = p2[1]-p1[1]
        p1_coordinates = np.array([p1[0]*math.cos(p1[1]),p1[0]*math.sin(p1[1])])
        p2_coordinates = np.array([p2[0]*math.cos(p2[1]),p2[0]*math.sin(p2[1])])


        # Angle of the normal of the baseline (THE FINAL ORIENTATION +/-)
        angle_of_baseline_normal_wrt_xaxis = p1[1] + math.pi/2 - math.atan2(p2[0]*math.sin(angle_between_p1_p2),(p1[0]-p2[0]*math.cos(angle_between_p1_p2)))

        """ Define the pose for the charger """
        charger_coordinates = (p1_coordinates+p2_coordinates)/2
        charger_pose = np.array([charger_coordinates[0], charger_coordinates[1], angle_of_baseline_normal_wrt_xaxis])

        """ Define a waypoint in front of the charger a given distance away """
        # same orientation
        ref_point_dist = 3  # Distance from final goal, change by desire
        p1_p2_dy = p2[0]*math.sin(p2[1])-p1[0]*math.sin(p1[1])
        p1_p2_dx = p2[0]*math.cos(p2[1])-p1[0]*math.cos(p1[1])

        """ Consider the following conditions """
        if charger_pose[1] > 0:
            ref_point_x = charger_pose[0]-abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
            if p1_p2_dx < 0:
                ref_point_y = charger_pose[1]-abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
                ref_point_x = charger_pose[0]+abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
            elif p1_p2_dx > 0:
                ref_point_y = charger_pose[1]+abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
            elif p1_p2_dy == 0:  # dx = 0
                ref_point_y = charger_pose[1] - ref_point_dist
            else:  # dx = 0
                ref_point_y = charger_pose[1]

        elif charger_pose[1] < 0:
            ref_point_x = charger_pose[0]-abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
            if p1_p2_dx < 0:
                ref_point_y = charger_pose[1]+abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
            elif p1_p2_dx > 0:
                ref_point_y = charger_pose[1]-abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
            elif p1_p2_dy == 0:  # dx = 0
                ref_point_y = charger_pose[1] + ref_point_dist
            else:  # dx = 0
                ref_point_y = charger_pose[1]
        else:
            if p1_p2_dx != 0:
                angle_of_baseline_normal_wrt_xaxis = (math.pi/2) + math.atan2((p1[1]-0), (p1[0]-charger_pose[0]))
                if p1[1] > 0:
                    if p1_p2_dx < 0:
                        ref_point_x = charger_pose[0] - \
                            abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
                        ref_point_y = charger_pose[1] + \
                            abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
                    elif p1_p2_dx > 0:
                        ref_point_x = charger_pose[0] - \
                            abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
                        ref_point_y = charger_pose[1] - \
                            abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
                else:
                    if p1_p2_dx < 0:
                        ref_point_x = charger_pose[0] - \
                            abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
                        ref_point_y = charger_pose[1] - \
                            abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
                    elif p1_p2_dx > 0:
                        ref_point_x = charger_pose[0] - \
                            abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
                        ref_point_y = charger_pose[1] + \
                            abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
            else:  # p1_p2_dx = 0
                ref_point_x = charger_pose[0] - ref_point_dist
                ref_point_y = charger_pose[1]

        ref_point = np.array([ref_point_x, ref_point_y, angle_of_baseline_normal_wrt_xaxis])

        """ Return the pose of the charger and the calculated waypoint """
        return charger_pose, ref_point
        pose_time.sleep()

if __name__ == "__main__":
    rospy.init_node("charger_detector", anonymous=False)
    detect_charger_laser()
    rospy.spin()
