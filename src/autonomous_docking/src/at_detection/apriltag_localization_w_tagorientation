#! /usr/bin/env python

import rospy, actionlib, tf
from geometry_msgs.msg import Twist, Pose, PoseStamped, PoseArray
from sensor_msgs.msg import LaserScan
from apriltag_ros.msg import AprilTagDetection, AprilTagDetectionArray
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from std_msgs.msg import Float32
import numpy as np
import math
import angles

class detect_charger(object):
    def __init__(self):
        rospy.Subscriber("/tag_detections", AprilTagDetectionArray, self.apriltag_callback, queue_size=1)
        self.charger_pose_publisher = rospy.Publisher("/apriltag_charger_pose", PoseArray, queue_size=1)
        self.station_pose_publisher = rospy.Publisher("/apriltag_station_pose", PoseArray, queue_size=1)
        self.distance_publisher = rospy.Publisher("/apriltag0_range", Float32, queue_size=1)
        self.lt = tf.TransformListener()

    def apriltag_callback(self, tag_info):
        tag_rate = rospy.Rate(0.5)
        self.tag0_is_detected = False
        self.tag1_is_detected = False
        self.tag2_is_detected = False
        self.tag3_is_detected = False
        self.tag4_is_detected = False
        for tag_detected in tag_info.detections:
            if np.round(tag_detected.id) == 0:
                tag_0 = tag_detected
                self.tag0_is_detected = True
                rospy.loginfo("TAG 0 DETECTED")
            elif np.round(tag_detected.id) == 1:
                tag_1 = tag_detected
                self.tag1_is_detected = True
            elif np.round(tag_detected.id) == 2:
                tag_2 = tag_detected
                self.tag2_is_detected = True
            elif np.round(tag_detected.id) == 3:
                tag_3 = tag_detected
                self.tag3_is_detected = True
            elif np.round(tag_detected.id) == 4:
                tag_4 = tag_detected
                self.tag4_is_detected = True

        if len(tag_info.detections) >= 2:

            if self.tag1_is_detected and self.tag2_is_detected:
                charger_pose_array = PoseArray()
                rospy.loginfo("Charger detected!")
                """ THE CHARGER WILL BE ASSIGNED TAG WITH ID 1 AND ID 2,
                WHERE 1 WILL REPRESENT THE LEFT SIDE OF THE DOCK """
                position_tag1 = np.array([tag_1.pose.pose.pose.position.z,tag_1.pose.pose.pose.position.x])
                position_tag2 = np.array([tag_2.pose.pose.pose.position.z,tag_2.pose.pose.pose.position.x])
                # Determine charger_pose
                position_charger = (position_tag1+position_tag2)/2
                charger_pose = PoseStamped()
                charger_pose.pose.position.x = position_charger[0]
                charger_pose.pose.position.y = position_charger[1]
                charger_pose.pose.orientation.x = tag_1.pose.pose.pose.orientation.x
                charger_pose.pose.orientation.y = tag_1.pose.pose.pose.orientation.y
                charger_pose.pose.orientation.z = tag_1.pose.pose.pose.orientation.z
                charger_pose.pose.orientation.w = tag_1.pose.pose.pose.orientation.w
                rot_quat_charger = tag_1.pose.pose.pose.orientation
                [roll,pitch,yaw] = tf.transformations.euler_from_quaternion([rot_quat_charger.x,rot_quat_charger.y,rot_quat_charger.z,rot_quat_charger.w])
                """ Needs to be rotated pi/2 yaw to have correct final orientation"""
                pitch = 0 #2D assumption
                roll = 0 #2D assumption
                # yaw = yaw + math.pi
                charger_pose_quat = tf.transformations.quaternion_from_euler(roll,pitch,yaw)
                charger_pose.pose.orientation.x = charger_pose_quat[0]
                charger_pose.pose.orientation.y = charger_pose_quat[1]
                charger_pose.pose.orientation.z = charger_pose_quat[2]
                charger_pose.pose.orientation.w  = charger_pose_quat[3]
                charger_pose.header.frame_id = "camera"
                # transf = self.lt.lookupTransform("camera","map",rospy.Time(0))
                # charger_pose = self.lt.transformPose("map",charger_pose)
                """ CALCULATE INITIAL POSE TO OBTAIN BEFORE DOCKING """
                charger_initial_pose = PoseStamped()
                distance_tag1 = np.sqrt(tag_1.pose.pose.pose.position.z**2+tag_1.pose.pose.pose.position.x**2)
                distance_tag2 = np.sqrt(tag_2.pose.pose.pose.position.z**2+tag_2.pose.pose.pose.position.x**2)
                #Calculate angles
                angle_tag1 = math.atan(tag_1.pose.pose.pose.position.x/tag_1.pose.pose.pose.position.z)
                angle_tag2 = math.atan(tag_2.pose.pose.pose.position.x/tag_2.pose.pose.pose.position.z)
                tag1 = np.array([distance_tag1,angle_tag1])
                tag2 = np.array([distance_tag2,angle_tag2])
                charger_initial_pose_x, charger_initial_pose_y = self.calculate_waypoints(tag1,tag2)
                charger_initial_pose.pose.position.x = charger_initial_pose_x
                charger_initial_pose.pose.position.y = charger_initial_pose_y
                charger_initial_pose.pose.orientation.x = charger_pose_quat[0]
                charger_initial_pose.pose.orientation.y = charger_pose_quat[1]
                charger_initial_pose.pose.orientation.z = charger_pose_quat[2]
                charger_initial_pose.pose.orientation.w  = charger_pose_quat[3]
                # station_gate_pose = self.lt.transformPose("map",station_gate_pose)
                charger_pose_array.poses = [charger_pose.pose, charger_initial_pose.pose]
                self.charger_pose_publisher.publish(charger_pose_array)

                """ ......................................................"""

                """ Broadcasting the charger frame from the camera frame """
                br = tf.TransformBroadcaster()
                br2 = tf.TransformBroadcaster()

                # br.sendTransform((charger_pose.pose.position.y, 0, charger_pose.pose.position.x),
                #                  (ccharger_pose.pose.orientation.x,charger_pose.pose.orientation.y,charger_pose.pose.orientation.z,charger_pose.pose.orientation.w),
                #                  rospy.Time.now(),
                #                  'charger',
                #                  'camera')
                br.sendTransform((charger_pose.pose.position.x, charger_pose.pose.position.y, 0),
                                 (charger_pose.pose.orientation.x,charger_pose.pose.orientation.y,charger_pose.pose.orientation.z,charger_pose.pose.orientation.w),
                                 rospy.Time.now(),
                                 'charger',
                                 'base_link')
                br2.sendTransform((charger_initial_pose.pose.position.x, charger_initial_pose.pose.position.y, 0),
                                 (charger_initial_pose.pose.orientation.x,charger_initial_pose.pose.orientation.y,charger_initial_pose.pose.orientation.z,charger_initial_pose.pose.orientation.w),
                                 rospy.Time.now(),
                                 'charger_ref',
                                 'base_link')

            if self.tag3_is_detected and self.tag4_is_detected:
                station_gate_pose_array = PoseArray()
                """ THE STATION GATE WILL BE ASSIGNED TAG WITH ID 3 AND ID 4,
                WHERE 3 WILL REPRESENT THE LEFT SIDE OF THE DOCK """
                rospy.loginfo("Station gate detected!")
                position_tag3 = np.array([tag_3.pose.pose.pose.position.z,tag_3.pose.pose.pose.position.x])
                position_tag4 = np.array([tag_4.pose.pose.pose.position.z,tag_4.pose.pose.pose.position.x])
                # Determine pose of the gate at its midpoint
                station_gate_midpoint = (position_tag3+position_tag4)/2
                station_gate_pose.pose.position.x = station_gate_midpoint[0]
                station_gate_pose.pose.position.y = station_gate_midpoint[1]
                rot_quat_gate = tag_3.pose.pose.pose.orientation
                [roll,pitch,yaw] = tf.transformations.euler_from_quaternion([rot_quat_gate.x,rot_quat_gate.y,rot_quat_gate.z,rot_quat_gate.w])
                [roll_gate,pitch_gate,yaw_gate] = tf.transformations.euler_from_quaternion(rot_quat_gate)
                roll_gate = 0 #2D assumption
                pitch_gate = 0 #2D assumption
                yaw_gate = yaw_gate + math.pi # To represent the final orientation
                station_pose_quat = tf.transformations.quaternion_from_euler(roll,pitch,yaw)
                station_gate_pose.pose.orientation.x = station_pose_quat[0]
                station_gate_pose.pose.orientation.y = station_pose_quat[1]
                station_gate_pose.pose.orientation.z = station_pose_quat[2]
                station_gate_pose.pose.orientation.w  = station_pose_quat[3]
                station_gate_pose.header.frame_id = "camera"

                """ CALCULATE INITIAL POSE TO OBTAIN BEFORE ENTERING STATION """
                station_initial_pose = PoseStamped()
                distance_tag3 = np.sqrt(tag_3.pose.pose.pose.position.z**2+tag_3.pose.pose.pose.position.x**2)
                distance_tag4 = np.sqrt(tag_4.pose.pose.pose.position.z**2+tag_4.pose.pose.pose.position.x**2)
                #Calculate angles
                angle_tag3 = math.atan(tag_3.pose.pose.pose.position.x/tag_3.pose.pose.pose.position.z)
                angle_tag4 = math.atan(tag_4.pose.pose.pose.position.x/tag_4.pose.pose.pose.position.z)
                tag3 = np.array([distance_tag3,angle_tag3])
                tag4 = np.array([distance_tag4,angle_tag4])
                station_initial_pose_x, station_initial_pose_y = self.calculate_waypoints(tag3,tag4)
                station_initial_pose.pose.position.x = station_initial_pose_x
                station_initial_pose.pose.position.y = station_initial_pose_y
                station_initial_pose.pose.orientation.x = station_pose_quat[0]
                station_initial_pose.pose.orientation.y = station_pose_quat[1]
                station_initial_pose.pose.orientation.z = station_pose_quat[2]
                station_initial_pose.pose.orientation.w  = station_pose_quat[3]
                # station_gate_pose = self.lt.transformPose("map",station_gate_pose)
                station_gate_pose_array.poses = [station_gate_pose.pose, station_initial_pose.pose]
                self.station_pose_publisher.publish(station_gate_pose)

        else:
            rospy.loginfo("A pair of apriltags has not been detected yet....")

        if self.tag0_is_detected:
            """ TAG 0 WILL BE USED FOR RANGING WHEN LASER IS NOT PRESENT """
            position_tag0 = np.array([tag_0.pose.pose.pose.position.z,tag_0.pose.pose.pose.position.x])
            distance_to_tag0 = np.sqrt(position_tag0[0]**2+position_tag0[1]**2)
            self.distance_publisher.publish(distance_to_tag0)
            rospy.loginfo(distance_to_tag0)
        else:
            rospy.loginfo("Unable to find tag 0 for ranging")

        tag_rate.sleep()

    def calculate_waypoints(self,p_a,p_b):
        '''
        Caluclating a point a given distance (3m) in front of the charging station
        as an inital pose before the fine operation of the docking takes place.
        '''
        pose_time = rospy.Rate(10)

        """ Define p1 as the point with the smallest absolute angle. """
        if abs(p_a[1]) < abs(p_b[1]):
            p1 = p_a
            p2 = p_b
        else:
            p1 = p_b
            p2 = p_a

        angle_between_p1_p2 = p2[1]-p1[1]
        p1_coordinates = np.array([p1[0]*math.cos(p1[1]),p1[0]*math.sin(p1[1])])
        p2_coordinates = np.array([p2[0]*math.cos(p2[1]),p2[0]*math.sin(p2[1])])


        # Angle of the normal of the baseline (THE FINAL ORIENTATION +/-)
        angle_of_baseline_normal_wrt_xaxis = p1[1] + math.pi/2 - math.atan2(p2[0]*math.sin(angle_between_p1_p2),(p1[0]-p2[0]*math.cos(angle_between_p1_p2)))

        """ Define the pose for the charger """
        charger_coordinates = (p1_coordinates+p2_coordinates)/2
        pose_at_middle = np.array([charger_coordinates[0], charger_coordinates[1], angle_of_baseline_normal_wrt_xaxis])

        """ Define a waypoint in front of the charger a given distance away """
        # same orientation
        ref_point_dist = 2  # Distance from final goal, change by desire
        p1_p2_dy = p2[0]*math.sin(p2[1])-p1[0]*math.sin(p1[1])
        p1_p2_dx = p2[0]*math.cos(p2[1])-p1[0]*math.cos(p1[1])

        """ Consider the following conditions """
        if pose_at_middle[1] > 0:
            ref_point_x = pose_at_middle[0]-abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
            if p1_p2_dx < 0:
                ref_point_y = pose_at_middle[1]-abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
                ref_point_x = pose_at_middle[0]+abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
            elif p1_p2_dx > 0:
                ref_point_y = pose_at_middle[1]+abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
            elif p1_p2_dy == 0:  # dx = 0
                ref_point_y = pose_at_middle[1] - ref_point_dist
            else:  # dx = 0
                ref_point_y = pose_at_middle[1]

        elif pose_at_middle[1] < 0:
            ref_point_x = pose_at_middle[0]-abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
            if p1_p2_dx < 0:
                ref_point_y = pose_at_middle[1]+abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
            elif p1_p2_dx > 0:
                ref_point_y = pose_at_middle[1]-abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
            elif p1_p2_dy == 0:  # dx = 0
                ref_point_y = pose_at_middle[1] + ref_point_dist
            else:  # dx = 0
                ref_point_y = pose_at_middle[1]
        else:
            if p1_p2_dx != 0:
                angle_of_baseline_normal_wrt_xaxis = (math.pi/2) + math.atan2((p1[1]-0), (p1[0]-pose_at_middle[0]))
                if p1[1] > 0:
                    if p1_p2_dx < 0:
                        ref_point_x = pose_at_middle[0] - \
                            abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
                        ref_point_y = pose_at_middle[1] + \
                            abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
                    elif p1_p2_dx > 0:
                        ref_point_x = pose_at_middle[0] - \
                            abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
                        ref_point_y = pose_at_middle[1] - \
                            abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
                else:
                    if p1_p2_dx < 0:
                        ref_point_x = pose_at_middle[0] - \
                            abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
                        ref_point_y = pose_at_middle[1] - \
                            abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
                    elif p1_p2_dx > 0:
                        ref_point_x = pose_at_middle[0] - \
                            abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
                        ref_point_y = pose_at_middle[1] + \
                            abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
            else:  # p1_p2_dx = 0
                ref_point_x = pose_at_middle[0] - ref_point_dist
                ref_point_y = pose_at_middle[1]

        ref_pose = np.array([ref_point_x, ref_point_y, angle_of_baseline_normal_wrt_xaxis])

        """ Return the pose of the charger and the calculated waypoint """
        return ref_point_x,ref_point_y
        pose_time.sleep()

if __name__ == "__main__":
    rospy.init_node("tag_detections")
    detect_charger()
    rospy.spin()
