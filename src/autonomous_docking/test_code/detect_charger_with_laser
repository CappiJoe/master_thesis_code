#! /usr/bin/env python

import rospy, tf
from geometry_msgs.msg import Twist, Pose, PoseArray
from sensor_msgs.msg import LaserScan
import numpy as np
import math
import angles

class detect_charger_laser(object):
    def __init__(self):
        rospy.Subscriber("/scan", LaserScan, self.laser_scan, queue_size=1)
        self.charger_publisher = rospy.Publisher('/charger_waypoints', PoseArray, queue_size=1) # Publishing msg to the nav_vel topic. Twist as msg type.
        self.lt = tf.TransformListener()
        self.trans = tf.TransformerROS()


    def laser_scan(self, scan_msg):
        """ Get the data from the laser scan """
        rate = rospy.Rate(10)
        scan_ranges = scan_msg.ranges
        scan_angle_min = scan_msg.angle_min
        scan_angle_inc = scan_msg.angle_increment
        scan_intensities = np.zeros_like(scan_ranges) #scan_msg.intensities
        intensity_threshold = 15000 ###Change after testing

        ################################### FOR TEST ########################
        test_idx = [idx for idx,val in enumerate(scan_ranges) if val<51 and val>0]
        for k in test_idx:
            scan_intensities[k] = 16000
        ####################################################################


        """ Filter out point under the desired threshold """
        intense_points_distances = np.array([])
        intense_points_angles = np.array([])
        for idx, distance in enumerate(scan_ranges):
            point_intensity = scan_intensities[idx]
            if point_intensity > intensity_threshold:
                point_angle = scan_angle_min + idx*scan_angle_inc #Start angle + n.o. angle increment to current laser tag
                intense_points_distances = np.append(intense_points_distances, distance)
                intense_points_angles = np.append(intense_points_angles, point_angle)
        intense_points = np.array([intense_points_distances,intense_points_angles])


        """ Based on the mean distance, sort the group of points into two clusters"""
        close_cluster_distance = np.array([])
        close_cluster_angle = np.array([])
        far_cluster_distance = np.array([])
        far_cluster_angle = np.array([])
        for idx, val in enumerate(intense_points[0]):
            if val < np.mean(intense_points[0]):
                close_cluster_distance = np.append(close_cluster_distance,intense_points[0][idx])
                close_cluster_angle = np.append(close_cluster_angle,intense_points[1][idx])
            else:
                far_cluster_distance = np.append(far_cluster_distance,intense_points[0][idx])
                far_cluster_angle = np.append(far_cluster_angle,intense_points[1][idx])

        """ Define the two detected points as the mean of each cluster """
        closest_point = np.array([np.mean(close_cluster_distance),np.mean(close_cluster_angle)])
        furthest_point = np.array([np.mean(far_cluster_distance),np.mean(far_cluster_angle)])

        # Coordinates of the pillars
        closest_pillar_coor = np.array([closest_point[0]*math.cos(closest_point[1]),closest_point[0]*math.sin(closest_point[1])])
        furthest_pillar_coor = np.array([furthest_point[0]*math.cos(furthest_point[1]),furthest_point[0]*math.sin(furthest_point[1])])

        """ Define the waypoints """
        charger_pose, ref_point = self.calculate_waypoints(closest_point,furthest_point)
        ref_pose = Pose()
        ref_pose.position.x = ref_point[0]
        ref_pose.position.y = ref_point[1]
        ref_pose_quat = tf.transformations.quaternion_from_euler(0,0,ref_point[2])
        ref_pose.orientation.x = ref_pose_quat[0]
        ref_pose.orientation.y = ref_pose_quat[1]
        ref_pose.orientation.z = ref_pose_quat[2]
        ref_pose.orientation.w = ref_pose_quat[3]

        goal_pose = Pose()
        goal_pose.position.x = charger_pose[0]
        goal_pose.position.y = charger_pose[1]
        goal_pose_quat = tf.transformations.quaternion_from_euler(0,0,ref_point[2])
        goal_pose.orientation.x = goal_pose_quat[0]
        goal_pose.orientation.y = goal_pose_quat[1]
        goal_pose.orientation.z = goal_pose_quat[2]
        goal_pose.orientation.w = goal_pose_quat[3]
        print("Reference pose: %s" %str(ref_pose))
        print("The charger has the following pose: %s" %str(ref_pose))

        #lt.lookupTransform("map"," base_link",rospy.Time(0))
        #ref_pose = self.lt.lookupTransform("map","base_link",rospy.Time(0))
        # while not rospy.is_shutdown():
        #     try:
        #         self.lt.waitForTransform("base_link","map",rospy.Time(0),rospy.Duration(0.02))
        #         # print(trans)
        #         # self.trans.lookupTransform("base_link","odom",rospy.Time(0))
        #         ref_pose_map = self.lt.transformPose("odom",ref_pose)
        #         print("works?")
        #     except(tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
        #         try:
        #             self.lt.waitForTransform("base_link","odom",rospy.Time(0),rospy.Duration(0.02))
        #             # print(trans)
        #             # self.trans.lookupTransform("base_link","odom",rospy.Time(0))
        #             ref_pose_map = self.lt.transformPose("base_link",ref_pose)
        #             print("works?")
        #         except(tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
        #             ref_pose_map = None
        #             rospy.logwarn("Failed to transform pose")
        # print("Map coords: %s" %str(ref_pose_map))
        pose_array = PoseArray()
        pose_array.poses = [goal_pose,ref_pose]
        #pose_array.header = rospy.Time(0)
        self.charger_publisher.publish(pose_array)

        br = tf.TransformBroadcaster()
        br.sendTransform((ref_point[0], ref_point[1], 0),
                         tf.transformations.quaternion_from_euler(0, 0, ref_point[2]),
                         rospy.Time.now(),
                         'charger',
                         'base_link') #base_link
        rate.sleep()

    def calculate_waypoints(self,p_a,p_b):
        '''
        Caluclating a point a given distance (3m) in front of the charging station
        as an inital pose before the fine operation of the docking takes place.
        '''
        pose_time = rospy.Rate(10)

        """ Define p1 as the point with the smallest absolute angle. """
        if abs(p_a[1]) < abs(p_b[1]):
            p1 = p_a
            p2 = p_b
        else:
            p1 = p_b
            p2 = p_a

        angle_between_p1_p2 = p2[1]-p1[1]
        p1_coordinates = np.array([p1[0]*math.cos(p1[1]),p1[0]*math.sin(p1[1])])
        p2_coordinates = np.array([p2[0]*math.cos(p2[1]),p2[0]*math.sin(p2[1])])


        # Angle of the normal of the baseline (THE FINAL ORIENTATION +/-)
        angle_of_baseline_normal_wrt_xaxis = p1[1] + math.pi/2 - math.atan2(p2[0]*math.sin(angle_between_p1_p2),(p1[0]-p2[0]*math.cos(angle_between_p1_p2)))

        """ Define the pose for the charger """
        charger_coordinates = (p1_coordinates+p2_coordinates)/2
        charger_pose = np.array([charger_coordinates[0], charger_coordinates[1], angle_of_baseline_normal_wrt_xaxis])
        print("The charger's pose is: %s" % str(charger_pose))

        """ Define a waypoint in front of the charger a given distance away """
        # same orientation
        ref_point_dist = 3  # Distance from final goal, change by desire
        p1_p2_dy = p2[0]*math.sin(p2[1])-p1[0]*math.sin(p1[1])
        p1_p2_dx = p2[0]*math.cos(p2[1])-p1[0]*math.cos(p1[1])

        """ Consider the following conditions """
        if charger_pose[1] > 0:
            ref_point_x = charger_pose[0]-abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
            if p1_p2_dx < 0:
                ref_point_y = charger_pose[1]-abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
                ref_point_x = charger_pose[0]+abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
            elif p1_p2_dx > 0:
                ref_point_y = charger_pose[1]+abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
            elif p1_p2_dy == 0:  # dx = 0
                ref_point_y = charger_pose[1] - ref_point_dist
            else:  # dx = 0
                ref_point_y = charger_pose[1]

        elif charger_pose[1] < 0:
            ref_point_x = charger_pose[0]-abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
            if p1_p2_dx < 0:
                ref_point_y = charger_pose[1]+abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
            elif p1_p2_dx > 0:
                ref_point_y = charger_pose[1]-abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
            elif p1_p2_dy == 0:  # dx = 0
                ref_point_y = charger_pose[1] + ref_point_dist
            else:  # dx = 0
                ref_point_y = charger_pose[1]
        else:
            if p1_p2_dx != 0:
                angle_of_baseline_normal_wrt_xaxis = (math.pi/2) + math.atan2((p1[1]-0), (p1[0]-charger_pose[0]))
                if p1[1] > 0:
                    if p1_p2_dx < 0:
                        ref_point_x = charger_pose[0] - \
                            abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
                        ref_point_y = charger_pose[1] + \
                            abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
                    elif p1_p2_dx > 0:
                        ref_point_x = charger_pose[0] - \
                            abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
                        ref_point_y = charger_pose[1] - \
                            abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
                else:
                    if p1_p2_dx < 0:
                        ref_point_x = charger_pose[0] - \
                            abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
                        ref_point_y = charger_pose[1] - \
                            abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
                    elif p1_p2_dx > 0:
                        ref_point_x = charger_pose[0] - \
                            abs(ref_point_dist*math.cos(angle_of_baseline_normal_wrt_xaxis))
                        ref_point_y = charger_pose[1] + \
                            abs(ref_point_dist*math.sin(angle_of_baseline_normal_wrt_xaxis))
            else:  # p1_p2_dx = 0
                ref_point_x = charger_pose[0] - ref_point_dist
                ref_point_y = charger_pose[1]

        ref_point = np.array([ref_point_x, ref_point_y, angle_of_baseline_normal_wrt_xaxis])

        """ Return the pose of the charger and the calculated waypoint """
        return charger_pose, ref_point
        pose_time.sleep()

if __name__ == "__main__":
    rospy.init_node("charger_detector", anonymous=False)
    detect_charger_laser()
    rospy.spin()
